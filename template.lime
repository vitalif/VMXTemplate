// Подразумевается, что лексический анализатор зависим от работы синтаксического,
// знает о его состоянии и соответственно выдаёт либо лексемы "внутри" блоков кода,
// либо литералы "вне" оных

%token literal
%token name

%left ".."
%left "||" "OR" "XOR"
%left "&&" "AND"
%left "&"
%nonassoc "==" "!=" "<" ">" "<=" ">="
%left "+" "-"
%left "*" "/" "%"

%%
chunks: | chunks chunk
chunk: error | literal | "<!--" code "-->" | "{" exp "}"
code: "IF" exp | "ELSE" | elseif exp | "END" | "END" varref |
    "SET" varref | "SET" varref '=' exp |
    fn name '(' arglist ')' | fn name '(' arglist ')' '=' exp |
    for varref '=' exp | for varref | exp
fn: "FUNCTION" | "BLOCK" | "MACRO"
for: "FOR" | "FOREACH"
elseif: "ELSE" "IF" | "ELSIF" | "ELSEIF"

exp: exp ".." exp |
    exp "||" exp | exp "OR" exp | exp "XOR" exp |
    exp "&&" exp | exp "AND" exp |
    exp "&" exp |
    exp "==" exp | exp "!=" exp |
    exp "<" exp | exp ">" exp | exp "<=" exp | exp ">=" exp |
    exp "+" exp | exp "-" exp |
    exp "*" exp | exp "/" exp | exp "%" exp |
    p10
p10: p11 | '-' p11
p11: nonbrace | '(' exp ')' varpath | '!' p11 | "NOT" p11
nonbrace: '{' hash '}' | literal | varref | func '(' list_or_gthash ')' | func nonbrace
list_or_gthash: list | gthash
func: name | varref varpart
list: exp | exp ',' list
arglist: name | name ',' arglist |
hash: pair | pair ',' hash |
gthash: gtpair | gtpair ',' gthash |
pair: exp ',' exp | gtpair
gtpair: exp "=>" exp
varref: name | varref varpart
varpart: '.' name | '[' exp ']'
varpath: | varpath varpart
%%
