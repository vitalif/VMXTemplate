# Контекстно-свободная LIME-грамматика шаблонизатора
#
# Для корректной работы нужен патченый LIME со следующими изменениями:
# (*) Подменой лексемы 'lit' на 'str' в метаграмматике.
#     Это нужно, чтобы можно было юзать строковые лексемы типа '<!--'.
# (*) Для корректной обработки ошибок нужно, чтобы метод eat() возвращал
#     false при ошибке и true при успехе. Т.к. подразумевается, что лексический
#     анализатор зависим от работы синтаксического, знает о его состоянии и
#     соответственно выдаёт либо лексемы "внутри" блоков кода, либо литералы
#     "вне" оных.
# Взять таковой можно здесь: https://github.com/vitalif/lime
# Компилить так: php -d xdebug.max_nesting_level=200 lime.php template.lime > template.class
#
# {{ двойные скобки }} нужно исключительно чтобы маркеры начала и конца подстановки
# были уникальны в грамматике. Вместо них обычно используются { одинарные }, а
# выбор корректной лексемы - скобки или маркера - делает лексический анализатор.
# Но зато вместо { фигурных скобок } можно выбрать себе любые другие маркеры!
#
# Все выражения представляются массивом из двух значений: [ код выражения, флаг экранирования ]
# Флаг экранирования == true, если это выражение HTML-безопасно. При включённом auto_escape
# небезопасные выражения прогоняются через экранирование.
#
# Кстати:
# * Олдстайл BEGIN .. END ликвидирован
# * Возможно, нужно добавить в каком-то виде foreach ... as key => value
#
# PHP старее 5.4 не поддерживается из-за следующих причин:
# * используется $a ?: $b в выражении {a || b}
# * используется короткий синтаксис массивов [ $a, $b ]
# * используется синтаксис ($array_expression)[$key]

%class VMXTemplateParser
%start template

%token literal
%token incorrect
%token name
%token comment

%token ".."     "concatenation operator '..'"
%token "||"     "OR operator '||'"
%token "OR"     "OR operator 'OR'"
%token "XOR"    "XOR operator 'XOR'"
%token "AND"    "AND operator 'AND'"
%token "&&"     "AND operator '&&'"
%token "&"      "bitwise AND operator '&'"
%token "=="     "equality operator '=='"
%token "!="     "non-equality operator '!='"
%token "<"      "less than operator '<'"
%token ">"      "greater than operator '>'"
%token "<="     "less or equal operator '<='"
%token ">="     "greater or equal operator '>='"
%token "+"      "plus operator '+'"
%token "-"      "minus operator '-'"
%token "*"      "multiply operator '*'"
%token "/"      "divide operator '/'"
%token "%"      "mod operator '%'"
%token "("      "left round brace '('"
%token ")"      "right round brace '('"
%token "!"      "NOT operator '!'"
%token "NOT"    "NOT operator 'NOT'"
%token "{"      "left curly brace '{'"
%token "}"      "right curly brace '}'"
%token ","      "comma ','"
%token "=>"     "hash item operator '=>'"
%token "["      "left square brace '['"
%token "]"      "right square brace ']'"
%token "<!--"   "directive begin"
%token "-->"    "directive end"
%token "{{"     "substitution begin"
%token "}}"     "substitution end"

%left ".."
%left "||" "OR" "XOR"
%left "&&" "AND"
%nonassoc "==" "!=" "<" ">" "<=" ">="
%left "+" "-"
%left "&"
%left "*" "/" "%"

# Директивы

template = chunks {
    $this->template->st->AST = $1;
    $$ = '';
  }
.
chunks = {
    $$ = [];
  }
| chunks chunk {
    $$ = $1;
    if ($2) {
      $$[] = $2;
    }
  }
.
chunk = literal {
    $$ = [ 'literal', $1 ];
  }
| "<!--" code_chunk/c "-->" {
    $$ = $c;
  }
| "{{" exp/e "}}" {
    $$ = [ 'subst', $e ];
  }
| error/e {
    $$ = false;
  }
.
code_chunk = c_if/$ | c_set/$ | c_fn/$ | c_for/$ | exp/e {
    $$ = [ 'subst', $e ];
  }
.
c_if = "IF" exp/e "-->" chunks/if "<!--" "END" {
    $$ = [ 'if', [ $e, $if ] ];
  }
| "IF" exp/e "-->" chunks/if "<!--" "ELSE" "-->" chunks/else "<!--" "END" {
    $$ = [ 'if', [ $e, $if ], [ false, $else ] ];
  }
| "IF" exp/e "-->" chunks/if c_elseifs/ei chunks/ec "<!--" "END" {
    $$ = $ei;
    $$[count($$)-1] = $ec;
    $$ = array_merge([ 'if', [ $e, $if ] ], $ei);
  }
| "IF" exp/e "-->" chunks/if c_elseifs/ei chunks/ec "<!--" "ELSE" "-->" chunks/else "<!--" "END" {
    $$ = $ei;
    $$[count($$)-1] = $ec;
    $$[] = [ false, $else ];
    $$ = array_merge([ 'if', [ $e, $if ] ], $$);
  }
.
c_elseifs = "<!--" elseif exp/e "-->" {
    $$ = [ [ $e ] ];
  }
| c_elseifs/p chunks/cs "<!--" elseif exp/e "-->" {
    $$ = $p;
    $$[count($$)-1][] = $cs;
    $$[] = [ $e ];
  }
.
c_set = "SET" varref/v "=" exp/e {
    $$ = [ 'set', $v, [ 'subst', $e ] ];
  }
| "SET" varref/v "-->" chunks/cs "<!--" "END" {
    $$ = [ 'set', $v, $cs ];
  }
.
c_fn = fn name/name "(" arglist/args ")" "=" exp/exp {
    $$ = [ 'function', $name, $args, [ 'subst', $exp ] ];
  }
| fn name/name "(" arglist/args ")" "-->" chunks/cs "<!--" "END" {
    $$ = [ 'function', $name, $args, $cs ];
  }
.
c_for = for varref/varref "=" exp/exp "-->" chunks/cs "<!--" "END" {
    $$ = [ 'for', $varref, $exp, $cs ];
  }
.
fn = "FUNCTION" | "BLOCK" | "MACRO" .
for = "FOR" | "FOREACH" .
elseif = "ELSE" "IF" | "ELSIF" | "ELSEIF" .

# Выражения

exp: exp/a ".." exp/b {
    $$ = [ 'op', '.', $a, $b ];
  }
| exp/a "||" exp/b {
    $$ = [ 'op', '||', $a, $b ];
  }
| exp/a "OR" exp/b {
    $$ = [ 'op', '||', $a, $b ];
 }
| exp/a "XOR" exp/b {
    $$ = [ 'op', 'XOR', $a, $b ];
  }
| exp/a "&&" exp/b {
    $$ = [ 'op', '&&', $a, $b ];
  }
| exp/a "AND" exp/b {
    $$ = [ 'op', '&&', $a, $b ];
  }
| exp/a "==" exp/b {
    $$ = [ 'op', '==', $a, $b ];
  }
| exp/a "!=" exp/b {
    $$ = [ 'op', '!=', $a, $b ];
  }
| exp/a "<" exp/b {
    $$ = [ 'op', '<', $a, $b ];
  }
| exp/a ">" exp/b {
    $$ = [ 'op', '>', $a, $b ];
  }
| exp/a "<=" exp/b {
    $$ = [ 'op', '<=', $a, $b ];
  }
| exp/a ">=" exp/b {
    $$ = [ 'op', '>=', $a, $b ];
  }
| exp/a "+" exp/b {
    $$ = [ 'op', '+', $a, $b ];
  }
| exp/a "-" exp/b {
    $$ = [ 'op', '-', $a, $b ];
  }
| exp/a "&" exp/b {
    $$ = [ 'op', '&', $a, $b ];
  }
| exp/a "*" exp/b {
    $$ = [ 'op', '*', $a, $b ];
  }
| exp/a "/" exp/b {
    $$ = [ 'op', '/', $a, $b ];
  }
| exp/a "%" exp/b {
    $$ = [ 'op', '%', $a, $b ];
  }
| p10/$
.
p10: p11/$
| '-' p11/a {
    $$ = [ 'op', '-', $a ];
  }
.
p11: nonbrace/$
| '(' exp/e ')' varpath/p {
    $$ = [ 'varpath', $e, $p ];
  }
| '!' p11/a {
    $$ = [ 'op', '!', $a ];
  }
| "NOT" p11/a {
    $$ = [ 'op', '!', $a ];
  }
.
nonbrace: '{' hash/$ '}'
| literal/$
| varref/$
| name/f '(' ')' {
    $$ = [ 'call', $f, [] ];
  }
| name/f '(' list/args ')' {
    $$ = [ 'call', $f, $args ];
  }
| name/f '(' gthash/args ')' {
    $$ = [ 'call_block', $f, $args, $this->template->lexer->errorpos() ];
  }
| name/f nonbrace/arg {
    $$ = [ 'call', $f, [ $arg ] ];
  }
.
list: exp/e {
    $$ = [ $e ];
  }
| exp/e ',' list/l {
    $$ = $l;
    array_unshift($$, $e);
  }
.
arglist: name/n {
    $$ = [ $n ];
  }
| name/n ',' arglist/args {
    $$ = $args;
    array_unshift($$, $n);
  }
| {
    $$ = [];
  }
.
hash: pair/p {
    $$ = [ 'hash', $p ];
  }
| pair/p ',' hash/h {
    array_splice($h, 1, 0, [ $p ]);
    $$ = $h;
  }
| {
    $$ = [ 'hash' ];
  }
.
gthash: gtpair/p {
    $$ = [ 'hash', $p ];
  }
| gtpair/p ',' gthash/h {
    array_splice($h, 1, 0, [ $p ]);
    $$ = $h;
  }
.
pair: exp/k ',' exp/v {
    $$ = [ $k, $v ];
  }
| gtpair/$
.
gtpair: exp/k "=>" exp/v {
    $$ = [ $k, $v ];
  }
.
varref: name/n {
    $$ = [ 'varref', $n ];
  }
| varref/v varpart/p {
    $v[] = $p;
    $$ = $v;
  }
.
varpart: '.' namekw/n {
    $$ = [ 'index', $n ];
  }
| '[' exp/e ']' {
    $$ = [ 'index', $e ];
  }
| '.' namekw/n '(' ')' {
    $$ = [ 'method', $n, [] ];
  }
| '.' namekw/n '(' list/l ')' {
    $$ = [ 'method', $n, $l ];
  }
.
varpath: {
    $$ = [];
  }
| varpath/a varpart/p {
    $a[] = $p;
    $$ = $a;
  }
.
namekw: name
| "IF" | "END" | "ELSE" | "ELSIF" | "ELSEIF"
| "SET" | "OR" | "XOR" | "AND" | "NOT"
| "FUNCTION" | "BLOCK" | "MACRO" | "FOR" | "FOREACH"
.
