# Контекстно-свободная LIME-грамматика шаблонизатора
#
# ЗАМЕЧАНИЯ:
# (!) Для разбора нужен патченый LIME, в котором лексема 'lit' подменена на 'str'.
#     Это нужно, чтобы можно было юзать строковые лексемы типа '<!--'.
# (*) Подразумевается, что лексический анализатор зависим от работы синтаксического,
#     знает о его состоянии и соответственно выдаёт либо лексемы "внутри" блоков кода,
#     либо литералы "вне" оных
# (*) Олдстайл BEGIN .. END ликвидирован
# (*) Возможно, нужно добавить в каком-то виде foreach ... as key => value

%class VMXTemplateParser
%start chunks

%token literal
%token name

%token ".."     "concatenation operator (..)"
%token "||"     "OR operator (||)"
%token "or"     "OR operator (OR)"
%token "xor"    "XOR operator (XOR)"
%token "and"    "AND operator (AND)"
%token "&&"     "AND operator (&&)"
%token "&"      "bitwise AND operator (&)"
%token "=="     "equality operator (==)"
%token "!="     "non-equality operator (!=)"
%token "<"      "less than operator (<)"
%token ">"      "greater than operator (>)"
%token "<="     "less or equal operator (<=)"
%token ">="     "greater or equal operator (>=)"
%token "+"      "plus operator (+)"
%token "-"      "minus operator (-)"
%token "*"      "multiply operator (*)"
%token "/"      "divide operator (/)"
%token "%"      "mod operator (%)"
%token "("      "left round brace"
%token ")"      "right round brace"
%token "!"      "NOT operator (!)"
%token "not"    "NOT operator (NOT)"
%token "{"      "left curly brace"
%token "}"      "right curly brace"
%token ","      "comma"
%token "=>"     "hash item operator (=>)"
%token "["      "left square brace"
%token "]"      "right square brace"
%token "<!--"   "directive begin"
%token "-->"    "directive end"

%left ".."
%left "||" "OR" "XOR"
%left "&&" "AND"
%nonassoc "==" "!=" "<" ">" "<=" ">="
%left "+" "-"
%left "&"
%left "*" "/" "%"

# Директивы

chunks = {
    $$ = '';
  }
| chunks/cs chunk/c {
    $$ = $cs . $c;
  }
.
chunk = literal/l {
    $$ = '$t .= ' . $l . ";\n";
  }
| "<!--" code_chunk/c "-->" {
    $$ = $c;
  }
| "{" exp/e "}" {
    $$ = '$t .= ' . $e . ";\n";
  }
| error {
    $$ = $this->lexer->skip_error();
  }
.
code_chunk = c_if/$ | c_set/$ | c_fn/$ | c_for/$ | exp/$ .
c_if = "IF" exp/e "-->" chunks/if "<!--" "END" {
    $$ = "if (" . $e . ") {\n" . $if . "}\n";
  }
| "IF" exp/e "-->" chunks/if "<!--" "ELSE" "-->" chunks/else "<!--" "END" {
    $$ = "if (" . $e . ") {\n" . $if . "} else {\n" . $else . "}\n";
  }
| "IF" exp/e "-->" chunks/if c_elseifs/ei chunks/ec "<!--" "END" {
    $$ = "if (" . $e . ") {\n" . $if . $ei . $ec . "}\n";
  }
| "IF" exp/e "-->" chunks/if c_elseifs/ei chunks/ec "<!--" "ELSE" "-->" chunks/else "<!--" "END" {
    $$ = "if (" . $e . ") {\n" . $if . $ei . $ec . "} else {\n" . $else . "}\n";
  }
.
c_elseifs = "<!--" elseif exp/e "-->" {
    $$ = "} elseif (" . $e . ") {\n";
  }
| c_elseifs/p chunks/cs "<!--" elseif exp/e "-->" {
    $$ = $p . $cs . "} elseif (" . $e . ") {\n";
  }
.
c_set = "SET" varref/v "=" exp/e {
    $$ = $v . ' = ' . $e . "\n";
  }
| "SET" varref/v "-->" chunks/cs "<!--" "END" {
    $$ = "\$stack[] = \$t;\n\$t = '';\n" . $cs . $v . " = \$t;\narray_pop(\$stack);\n";
  }
.
c_fn = fn name/name "(" arglist/args ")" "=" exp/exp {
    $this->functions[$name] = array(
      'name' => $name,
      'args' => $args,
      'body' => 'function fn_'.$name." () {\nreturn ".$exp.";\n}\n",
      //'line' => $line, Ой, я чо - аргументы не юзаю?
      //'pos' => $pos,
    );
    $$ = '';
  }
| fn name/name "(" arglist/args ")" "-->" chunks/cs "<!--" "END" {
    $this->functions[$name] = array(
      'name' => $name,
      'args' => $args,
      'body' => 'function fn_'.$name." () {\$stack = array();\n\$t = '';\n".$cs."\nreturn \$t;\n}\n",
      //'line' => $line,
      //'pos' => $pos,
    );
    $$ = '';
  }
.
c_for = for varref/varref "=" exp/exp "-->" chunks "<!--" "END" {
    $varref_index = substr($varref, 0, -1) . ".'_index']";
    $$ = "\$stack[] = ".$varref.";
\$stack[] = ".$varref_index.";
\$stack[] = 0;
foreach (self::array1($exp) as \$item) {
".$varref." = \$item;
".$varref_index." = \$stack[count(\$stack)-1]++;
" . $cs . "}
array_pop(\$stack);
".$varref_index." = array_pop(\$stack);
".$varref." = array_pop(\$stack);
";
  }
.
fn = "FUNCTION" | "BLOCK" | "MACRO" .
for = "FOR" | "FOREACH" .
elseif = "ELSE" "IF" | "ELSIF" | "ELSEIF" .

# Выражения

exp: exp/a ".." exp/b {
    $$ = '(' . $a . ' . ' . $b . ')';
  }
| exp/a "||" exp/b {
    $$ = 'self::perlish_or(' . $a . ', ' . $b . ')';
  }
| exp/a "OR" exp/b {
    $$ = 'self::perlish_or(' . $a . ', ' . $b . ')';
  }
| exp/a "XOR" exp/b {
    $$ = '(' . $a . ' XOR ' . $b . ')';
  }
| exp/a "&&" exp/b {
    $$ = '(' . $a . ' && ' . $b . ')';
  }
| exp/a "AND" exp/b {
    $$ = '(' . $a . ' && ' . $b . ')';
  }
| exp/a "==" exp/b {
    $$ = '(' . $a . ' == ' . $b . ')';
  }
| exp/a "!=" exp/b {
    $$ = '(' . $a . ' != ' . $b . ')';
  }
| exp/a "<" exp/b {
    $$ = '(' . $a . ' < ' . $b . ')';
  }
| exp/a ">" exp/b {
    $$ = '(' . $a . ' > ' . $b . ')';
  }
| exp/a "<=" exp/b {
    $$ = '(' . $a . ' <= ' . $b . ')';
  }
| exp/a ">=" exp/b {
    $$ = '(' . $a . ' >= ' . $b . ')';
  }
| exp/a "+" exp/b {
    $$ = '(' . $a . ' + ' . $b . ')';
  }
| exp/a "-" exp/b {
    $$ = '(' . $a . ' - ' . $b . ')';
  }
| exp/a "&" exp/b {
    $$ = '(' . $a . ' & ' . $b . ')';
  }
| exp/a "*" exp/b {
    $$ = '(' . $a . ' * ' . $b . ')';
  }
| exp/a "/" exp/b {
    $$ = '(' . $a . ' / ' . $b . ')';
  }
| exp/a "%" exp/b {
    $$ = '(' . $a . ' % ' . $b . ')';
  }
| p10/$
.
p10: p11/$
| '-' p11/a {
    $$ = '(-'.$a.')';
  }
.
p11: nonbrace
| '(' exp/e ')' varpath/p {
    $$ = '('.$e.')'.$p;
  }
| '!' p11/a {
    $$ = '(!'.$a.')';
  }
| "NOT" p11/a {
    $$ = '(!'.$a.')';
  }
.
nonbrace: '{' hash/h '}' {
    $$ = 'array(' . $h . ')';
  }
| literal/$
| varref/$
| name/f '(' ')' {
    $$ = $this->compile_function($f, []);
  }
| name/f '(' list/args ')' {
    $$ = $this->compile_function($f, $args);
  }
| name/f '(' gthash/args ')' {
    $$ = "\$this->parent->call_block(".$f.", ".$args.")";
  }
| name/f nonbrace/arg {
    $$ = $this->compile_function($f, [ $arg ]);
  }
| method/f '(' ')' {
    $$ = $f.'()';
  }
| method/f '(' list/args ')' {
    $$ = $f.'('.implode(', ', $args).')';
  }
.
method: varref/v '.' name/m {
    $$ = $v.'->'.$m;
  }
.
list: exp/e {
    $$ = [ $e ];
  }
| exp/e ',' list/l {
    $$ = $l;
    array_unshift($$, $e);
  }
.
arglist: name/n {
    $$ = [ $n ];
  }
| name/n ',' arglist/args {
    $$ = $args;
    array_unshift($$, $n);
  }
| {
    $$ = [];
  }
.
hash: pair/$
| pair/p ',' hash/h {
    $$ = $p . ', ' . $h;
  }
| {
    $$ = '';
  }
.
gthash: gtpair/p {
    $$ = $p;
  }
| gtpair/p ',' gthash/h {
    $$ = $p . ', ' . $h;
  }
.
pair: exp/k ',' exp/v {
    $$ = $k . ' => ' . $v;
  }
| gtpair/$
.
gtpair: exp/k "=>" exp/v {
    $$ = $k . ' => ' . $v;
  }
.
varref: name/n {
    $$ = '$this->tpldata[\''.addcslashes($n, '\\\'').'\']';
  }
| varref/v varpart/p {
    $$ = $v . $p;
  }
.
varpart: '.' name/n {
    $$ = '[\''.addcslashes($n, '\\\'').'\']';
  }
| '[' exp/e ']' {
    $$ = '['.$e.']';
  }
.
varpath: {
    $$ = '';
  }
| varpath/a varpart/p {
    $$ = $a . $p;
  }
.
